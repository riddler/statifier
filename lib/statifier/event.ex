defmodule Statifier.Event do
  @moduledoc """
  Represents an event that can be sent to a state chart.

  Events can be external (from outside the state chart) or internal
  (generated by the state chart itself, e.g., from <raise> actions).
  """

  defstruct [:name, data: %{}, origin: :external]

  @type origin :: :external | :internal
  @type t :: %__MODULE__{
          name: String.t(),
          data: map(),
          origin: origin()
        }

  @doc """
  Create a new external event.
  """
  @spec new(String.t(), map()) :: t()
  def new(name, data \\ %{}) when is_binary(name) and is_map(data) do
    %__MODULE__{name: name, data: data, origin: :external}
  end

  @doc """
  Create a new internal event.
  """
  @spec internal(String.t(), map()) :: t()
  def internal(name, data \\ %{}) when is_binary(name) and is_map(data) do
    %__MODULE__{name: name, data: data, origin: :internal}
  end

  @doc """
  Check if an event is external.
  """
  @spec external?(t()) :: boolean()
  def external?(%__MODULE__{origin: :external}), do: true
  def external?(%__MODULE__{}), do: false

  @doc """
  Check if an event is internal.
  """
  @spec internal?(t()) :: boolean()
  def internal?(%__MODULE__{origin: :internal}), do: true
  def internal?(%__MODULE__{}), do: false

  @doc """
  Check if this event matches a transition's event specification.

  Supports SCXML event matching patterns:
  - Universal wildcard: "*" matches any event
  - Prefix matching: "foo" matches "foo", "foo.bar", "foo.bar.baz"
  - Multiple descriptors: "foo bar" matches "foo" OR "bar" (and their prefixes)
  - Wildcard suffix: "foo.*" matches "foo.bar", "foo.baz" (but not "foo")
  """
  @spec matches?(t(), String.t() | nil) :: boolean()
  def matches?(%__MODULE__{}, nil), do: false

  # Universal wildcard matches any event
  def matches?(%__MODULE__{name: _name}, "*"), do: true

  def matches?(%__MODULE__{name: name}, event_spec) when is_binary(event_spec) do
    # Split event descriptor into space-separated alternatives
    descriptors = String.split(event_spec, " ")
    event_tokens = String.split(name, ".")

    # Event matches if ANY descriptor matches
    Enum.any?(descriptors, fn descriptor ->
      if String.ends_with?(descriptor, ".*") do
        # Wildcard pattern: "foo.*" matches "foo.bar" but not "foo"
        prefix = String.slice(descriptor, 0, String.length(descriptor) - 2)
        prefix_tokens = String.split(prefix, ".")
        matches_wildcard_prefix?(event_tokens, prefix_tokens)
      else
        # Regular prefix matching: "foo" matches "foo", "foo.bar", etc.
        descriptor_tokens = String.split(descriptor, ".")
        matches_prefix?(event_tokens, descriptor_tokens)
      end
    end)
  end

  # Check if event tokens match spec tokens as prefix
  defp matches_prefix?(event_tokens, spec_tokens)
       when length(spec_tokens) <= length(event_tokens) do
    spec_length = length(spec_tokens)
    event_prefix = Enum.take(event_tokens, spec_length)
    event_prefix == spec_tokens
  end

  defp matches_prefix?(_event_tokens, _spec_tokens), do: false

  # Check wildcard prefix patterns like "foo.*"
  # Requires event to have MORE tokens than prefix (wildcard means additional tokens)
  defp matches_wildcard_prefix?(event_tokens, prefix_tokens)
       when length(event_tokens) > length(prefix_tokens) do
    prefix_length = length(prefix_tokens)
    event_prefix = Enum.take(event_tokens, prefix_length)
    event_prefix == prefix_tokens
  end

  defp matches_wildcard_prefix?(_event_tokens, _prefix_tokens), do: false
end
